= Ansible
:toc: manual

== 什么是 Ansible

Ansible 是一款开源自动化平台，它是一款简单自动化语言，能够在 Ansible Playbook 中完美地描述 IT 基础架构。它同时提供了一个自动化引擎用来执行 Asible Playbook。

Ansible 具有多个重要的优点:

* *跨平台支持* - Ansible 提供 Linux、Windows、UNIX 和网络设备的无代理支持，适用于物理、虚拟、云和容器环境。
* *用户可读的自动化* - Ansible Playbook 采用 YAML 文本文件编写，易于阅读，有助于确保所有人都能理解它们的用途。
* *完美描述应用* - 可以通过 Ansible Playbook 进行每一种更改，并描述和记录应用环境的每一个方面。
* *轻松管理版本控制* - Ansible Playbook 和项目是纯文本。它们可以视作源代码，放在您的现有版本控制系统中。
* *支持动态清单* - 可以从外部来源动态更新 Ansible 管理的计算机的列表，随时获取所有受管服务器的当前正确列表，不受基础架构或位置的影响。
* *编排可与其他系统轻松集成* - 能够利用环境中现有的 HP SA、Puppet、Jenkins、红帽卫星和其他系统，并且集成到您的 Ansible 工作流中。

Ansible 是第一款可以在整个 IT 范围读取和编写的自动化语言。它也是唯一能够从头至尾自动化应用生命周期和持续交付管道的自动化引擎。

image:img/devops-language-diagram.png[]

Ansible 方式:

* *简单高效* - 越简单越好。Ansible 的设计宗旨是工具易用，自动化易写易读。您应利用这一特点在创建自动化时追求简单化。
* *专为易读性优化* - Ansible 自动化语言围绕简单易读的声明性文本文件来构建。正确编写的 Ansible Playbook 可以清楚地记录您的工作流自动化。
* *声明式思维* - Ansible 是一种要求状态引擎。它通过表达您希望系统处于何种状态来解决如何自动化 IT 部署的问题。Ansible 的目标是通过仅执行必要的更改，使您的系统处于所需的状态。试图将 Ansible 视为脚本语言并非正确的做法。

== 安装

Ansible 易于安装。Ansible 软件只需要安装到要运行它的一个（或多个）控制节点上。由 Ansible 管理的主机不需要安装 Ansible。这种安装涉及相对较少的步骤，其要求也最少。

控制节点应当是 Linux 或 UNIX 系统。不支持将 Microsoft Windows 用作控制节点，但 Windows 系统可以是受管主机。

[source, bash]
.*安装 1/3 - 安装 Python(本步骤是可选择的)*
----
sudo yum install -y python
----

[source, bash]
.*安装 2/3 - 安装 Ansible*
----
sudo yum install -y ansible
----

[source, bash]
.*安装 3/3 - 安装验证*
----
ansible --version
----

== 部署

=== Inventory 编写

Inventory 即清单，一个 清单定义 Ansible 将要管理的一系列主机。这些主机也可以分配到 组中，以便进行集中管理。组可以包含子组，主机也可以是多个组的成员。清单还可以设置应用到它所定义的主机和组的变量。

可以通过两种方式定义主机清单：

* 静态主机清单，可以通过文本文件来定义。
* 动态主机清单，可以根据需要利用外部信息提供程序通过脚本或其他程序来生成。

[source, text]
.*1. 静态清单示例*
----
[webservers]
web1.example.com
web2.example.com

[dbservers]
db1.example.com
db2.example.com

[allservers:children]
webservers
dbservers
----

[source, text]
.*2. 清单测试*
----
$ ansible allservers --list-hosts
  hosts (4):
    web1.example.com
    web2.example.com
    db1.example.com
    db2.example.com
----

清单文件可以覆盖 `/etc/ansible/hosts` 文件，也可以在允许时通过 `--inventory PATHNAME` 或 `-i PATHNAME` 选项在命令行中指定清单文件的位置，其中 PATHNAME 是所需清单文件的路径。

[source, text]
----
ansible -i Inventory
----

NOTE: 更多关于 Ansible 清单，参照 https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html[链接]。

=== 配置文件

.*Ansible 配置文件 & 优先级*
|===
|文件路径 |说明 |优先级

|$ANSIBLE_CONFIG
|使用 $ANSIBLE_CONFIG 变量指定配置文件路径，优先级最高
|4

|./ansible.cfg
|放置与执行 ansible 命令的目录
|3

|~/.ansible.cfg
|当前用户主目录下
|2

|/etc/ansible/ansible.cfg
|全局配置文件路径
|1
|===

NOTE: 优先级高的配置文件或覆盖优先级低的配置。

[source, text]
.*ansible --version 输出配置的位置*
----
$ ansible --version
ansible 2.3.1.0
  config file = /etc/ansible/ansible.cfg
...
----

[source, text]
.*执行 Ansible 命令时使用 -v 选项输出配置的位置*
----
$ ansible servers --list-hosts -v
Using /etc/ansible/ansible.cfg as config file
...
----

.*Ansible 配置文件中的配置分组*
[cols="2,2,5a"]
|===
|位置 |说明 |示例

|[defaults]
|配置文件中的大部分设置分组
|
[source, text]
----
[defaults]
#清单位置
inventory = ./inventory

#连接设置
remote_user = root
ask_pass = true
----

|[privilege_escalation]
|包含的设置用于定义如何对受管主机执行需要特权升级的操作。
|
[source, text]
----
[privilege_escalation]
become = true
become_method = sudo
become_user = root
become_ask_pass = false
----

|[paramiko_connection]、[ssh_connection]、[accelerate]
|包含的设置用于优化与受管主机的连接
|

|[selinux]
|包含的设置用于定义如何配置 SELinux 交互
|
|===

.*Ansible 配置项*
|===
|配置项 |说明 |命令行选项

|inventory
|Ansible 清单的位置
|-i

|remote_user
|用于建立与受管主机的连接的用户帐户
|-u

|ask_pass
|提示输入以远程用户身份连接时要使用的密码
|

|become
|为受管主机上的操作启用或禁用特权升级
|--become、-b

|become_method
|要在受管主机上使用的特权升级方法
|--become-method

|become_user
|在受管主机上升级特权的用户帐户
|--become-user

|become_ask_pass
|定义受管主机上的特权升级是否提示输入密码
|--ask-become-pass、 -K
|===

=== 运行临时命令

什么是运行临时命令？临时命令是简单的一行式操作，无需编写 playbook 即可运行的命令。它们对快速测试和更改很有用处。例如，您可以使用临时命令确保一组服务器上的 /etc/hosts 文件中存在某一特定的行。您可以使用另一个临时命令在许多不同的计算机上高效重启一项服务，或者确保特定的软件包为最新版本。您还可以将它用于在一个或多个主机上运行任意命令，从而运行某一程序或收集信息。

[source, text]
.*运行临时命令范式*
----
ansible host-pattern -m module [-a 'module arguments'] [-i inventory]
----

* `host-pattern` - 用于指定应在其上运行临时命令的受管主机。它可以是清单中的特定受管主机或主机组。
* `-m` -  Ansible 应在目标主机上运行的 模块的名称取为参数。模块是为了实施您的任务而执行的小程序。
* `-a` - 以带引号字符串形式取这些参数的列表。
* `-i` - 指定要使用的其他清单位置，取代当前 Ansible 配置文件中的默认位置。

[source, text]
.*ansible-doc -l 列出所有模块*
----
$ ansible-doc -l
----

[source, text]
.*ansible-doc NAME 查看模块文档*
----
$ ansible-doc ping
----

.*常见临时命令示例*
[cols="2,5a"]
|===
|名称 |示例

|ping
|
[source, text]
----
$ ansible all -m ping
servera.lab.example.com \| SUCCESS => {
    "changed": false,
    "ping": "pong"
}
----

|创建用户
|
[source, text]
----
$ ansible -m user -a 'name=newbie uid=4000 state=present' \
> servera.lab.example.com
servera.lab.example.com \| SUCCESS => {
    "changed": true,
    "comment": "",
    "createhome": true,
    "group": 4000,
    "home": "/home/newbie",
    "name": "newbie",
    "shell": "/bin/bash",
    "state": "present",
    "system": false,
    "uid": 4000
}
----

|使用 command 模块运行命令
|
[source, text]
----
$ ansible mymanagedhosts -m command -a /usr/bin/hostname -o
host1.lab.example.com \| SUCCESS \| rc=0 >> (stdout) host1.lab.example.com
host2.lab.example.com \| SUCCESS \| rc=0 >> (stdout) host2.lab.example.com
----
|===

=== 动态清单

Ansible 支持通过 动态清单脚本在每当 Ansible 执行时从这些类型的来源检索当前的信息，使清单能够实时得到更新。这些脚本是可以执行的程序，能够从一些外部来源收集信息，并以 JSON 格式输出清单。

动态清单脚本的使用方式与静态清单文本文件一样。清单的位置可以直接在当前的 ansible.cfg 文件中指定，或者通过 -i 选项指定。如果清单文件可以执行，它将被视为动态清单程序，Ansible 则将尝试运行它来生成清单。如果文件不可执行，它将被视为静态清单。

NOTE: https://github.com/ansible/ansible/tree/devel/contrib/inventory 中有大量现有的动态清单脚本，包括对私有云平台、公共云平台、虚拟化平台、PaaS 平台等管理。

== Playbooks

=== Ansible Playbook Vs 临时命令

*运行临时命令* 部分运行 ansible 临时命令，临时命令可以作为一次性命令对一组目标主机运行一项简单的任务。不过，若要真正发挥 Ansible 的力量，需要了解如何使用 playbook 以可轻松重复的方式对一组目标主机执行多项复杂的任务。

一个 `play` 中含有一组有序的任务，应针对清单中选定的主机运行这些任务。而 `playbook` 是一个文本文件，其中包含由一个或多个按顺序运行的 `play` 组成的列表。 

`Play` 可以让您将一系列冗长而复杂的手动管理任务转变为可轻松重复的例程，并且具有可预测的成功成果。在 `playbook` 中，您可以将 `play` 内的任务序列保存为人类可读并可立即运行的形式。根据任务的编写方式，任务本身记录了部署应用或基础架构所需的步骤。

`Playbook` 是以 `YAML` 格式编写的文本文件，通常使用扩展名 `yml` 保存。`Playbook` 主要使用空格字符缩进来表示其数据结构。`YAML` 对用于缩进的空格数量没有严格的要求，但有两个基本的规则:

* 处于层次结构中同一级别的数据元素（例如同一列表中的项目）必须具有相同的缩进量。
* 如果项目属于其他项目的子项，其缩进量必须大于父项。

`Playbook` 开头的一行由三个破折号 (---) 组成，这是文档开始标记。其末尾也可能使用三个圆点 (...) 作为文档结束标记，尽管在实践中这很少用于 `playbook`。

在这两个标记之间，会以一个 `play` 列表的形式来定义 `playbook`。YAML 列表中的项目以一个破折号加空格开头。例如，YAML 列表可能显示如下：

[source, text]
----
- apple
- orange
- grape
----

.*运行 Playbook*
|===
|名称 |命令

|运行
|`ansible-playbook sample.yml`

|语法验证
|`ansible-playbook --syntax-check sample.yml`

|执行空运行
|`ansible-playbook -C sample.yml`
|===

=== 包含多个 play 的 playbook

Playbook 是一个 YAML 文件，含有由一个或多个 play 组成的列表。记住一个 play 按顺序列出了要对清单中的选定主机执行的任务。因此，如果一个 playbook 中含有多个 play，每个 play 可以将其任务应用到单独的一组主机。

在编排可能涉及对不同主机执行不同任务的复杂部署时，这会大有帮助。Playbook 可以这样编写：对一组主机运行一个 play，完成后再对另一组主机运行另一个 play。（当然，如果出于某种原因有必要，第二个 play 也可以针对同一组主机运行）。

编写包含多个 play 的 playbook 非常简单。Playbook 中的各个 play 编写为 playbook 中的顶级列表项。各个 play 是含有常用 play 指令的列表项。

*用户属性*

Playbook 中的任务通常通过与受管主机的网络连接来执行。与临时命令相同，用于任务执行的用户帐户取决于 Ansible 配置文件 /etc/ansible/ansible.cfg 中的不同参数。执行任务的用户可以通过 remote_user 参数来定义。不过，如果启用了特权升级，become_user 等其他参数也会发生作用。

如果用于任务执行的 Ansible 配置中定义的远程用户不合适，可以通过在 play 中使用 remote_user 属性来覆盖。

[source, text]
----
remote_user: remoteuser
----

*特权升级属性*

也提供额外的属性，从而在 playbook 内定义特权升级参数。become 布尔值参数可用于启用或禁用特权升级，无论它在 Ansible 配置文件中的定义为何。一如平常，它可以取 yes 或 true 值来启用特权升级，或者取 no 或 false 值来禁用它。

[source, text]
----
become: true
----

如果启用了特权升级，则可以使用 become_method 属性来定义特定 play 期间要所要使用的特权升级方法。以下示例中指定 sudo 用于特权升级。

[source, text]
----
become_method: sudo
----

此外，启用了特权升级时，become_user 属性可定义特定 play 上下文内要用于特权升级的用户帐户。

[source, text]
----
become_user: privileged_user
----

=== Playbook 语法

.*Playbook 语法*
[cols="2,5a"]
|===
|名称| 说明

|YAML 注释
|注释用于提高可读性。在 YAML 中，编号或井号符号 (#) 右侧的所有内容都是注释。如果注释的左侧有内容，请在该编号符号的前面加一个空格。

[source, text]
.*井号右侧的所有内容都是注释*
----
# This is a YAML comment
----

[source, text]
.*左侧有内容，则井号前面加一个空格*
----
some data # This is also a YAML comment
----

|YAML 字符串
|YAML 中的字符串通常不需要放在引号里，即使字符串中包含空格。如果需要，字符串可以用双引号或单引号括起。

[source, text]
----
this is a string

'this is a string'

"this is a string"
----

|多行字符串
|编写多行字符串有两种方式。一种方式是，使用竖线 (\|) 字符表示保留字符串中的换行字符。

[source, text]
----
include_newlines: \|
          Example Company
          123 Main Street
          Atlanta, GA 30303
----

编写多行字符串的另一种方式是，使用大于号 (>) 字符来表示换行字符转换成空格并且行内的引导空白将被删除。这种方法通常用于将很长的字符串在空格字符处断行，使它们跨占多行来提高可读性。

[source, text]
----
fold_newlines: >
          This is
          a very long,
          long, long, long
          sentence.
----

|YAML 字典
|YAML 字典有两种方式，以缩进块的形式编写的键值对集合，如下所示：

[source, text]
----
  name: svcrole
  svcservice: httpd
  svcport: 80
----

字典也可以使用以花括号括起的内联块格式编写，如下方所示：

[source, text]
----
{name: svcrole, svcservice: httpd, svcport: 80}
----

大多数情形中应避免内联块格式，因为其可读性较差。不过，至少有一种情形中会较常使用它。

|YAML 列表
|YAML 列表有两种表述方式，使用普通单破折号语法编写的列表：

[source, text]
----
  hosts:
    - servera
    - serverb
    - serverc
----

列表也有以方括号括起的内联格式，如下方所示：

[source, text]
----
hosts: [servera, serverb, serverc]
----

|YAML 键值对
|通常，您会将相同的任务编写为如下所示：

[source, text]
----
  tasks:
    - name: normal form
      service:
        name: httpd
        enabled: true
        state: started
----

某些 playbook 可能使用较旧的简写方法，通过将模块的键值对放在与模块名称相同的行上来定义任务。例如，您可能会看到这种语法：

[source, text]
----
  tasks:
    - name: shorthand form
      service: name=httpd enabled=true state=started
----

|===

== 变量(Variables) & 事实(Facts) & 包含(Inclusions)

=== 变量(Variables)

Ansible 支持利用变量存储整个 Ansible 项目的文件中可重复使用的值。这有助于简化项目的创建和维护，并减少错误的发生。

通过变量，您可以轻松地在 Ansible 项目中管理给定环境的动态值。例如，变量可以包含下面这些值:

* 要创建的用户
* 要安装的软件包
* 要重新启动的服务
* 要删除的文件
* 要从互联网检索的存档

变量的名称由字符串组成，它必须*以字母开头，并且只能含有字母、数字和下划线*。

.*变量作用域*
[cols="2,2,5a"]
|===
|变量类型 |作用域 |说明

|Global 变量
|从命令行或 Ansible 配置文件设置的变量
|命令行中传递参数到 ansible 或 ansible-playbook 命令

[source, text]
----
$ ansible-playbook main.yml --limit=demo2.example.com -e "package=apache"
----

|Play 变量
|在 play 和相关结构中设置的变量
|在 playbook 开头的 vars 块中定义变量：

[source, text]
----
- hosts: all
  vars:
    user: joe
    home: /home/joe
----

可选择的，在 playbook 开头的 vars_files 块中关联一个外部变量文件：

[source, text]
.*1 - vars_files*
----
- hosts: all
  vars_files:
    - vars/users.yml
----

[source, text]
.*2 - vars/users.yml 文件定义的变量*
----
user: joe
home: /home/joe
----

声明了变量后，管理员可以在任务中使用这些变量。若要引用变量，可将变量名称放在双花括号内。在任务执行时，Ansible 会将变量替换为其值：

[source, text]
----
tasks:
  # This line will read: Creates the user joe
  - name: Creates the user {{ user }}
    user:
      # This line will create the user named Joe
      name: "{{ user }}"
----

|Host 变量
|由清单、事实收集或注册的任务，在主机组和个别主机上设置的变量
|主机变量应用到特定的主机，而 组变量则应用到某一或某组主机组中的所有主机。主机变量优先于组变量。

[source, text]
.*主机 demo.example.com 定义变量 ansible_user*
----
[servers]
demo.example.com  ansible_user=joe
----

[source, text]
.*servers 组定义变量 user*
----
[servers]
demo1.example.com
demo2.example.com

[servers:vars]
user=joe
----

使用 group_vars 和 host_vars 目录, 创建两个目录 group_vars 和 host_vars。这两个目录分别包含用于定义组变量和主机变量的文件。

[source, text]
.*组和主机变量定义的 group_vars 和 host_vars 目录*
----
~/project/group_vars/datacenters
~/project/group_vars/datacenter1
~/project/group_vars/datacenter2

~/project/host_vars/demo1.example.com
~/project/host_vars/demo2.example.com
~/project/host_vars/demo3.example.com
~/project/host_vars/demo4.example.com
----

|===

NOTE: 如果在多个级别上定义了相同名称的变量，则采用级别高的变量，Global 变量会覆盖 Play 和 Host 变量，Play 变量会覆盖 Host 变量。

*变量数组* - 除了将与同一元素相关的一段配置数据（软件包列表、服务列表和用户列表等）分配到多个变量外，管理员也可以使用 数组。而这种做法的一个好处在于，数组是可以浏览的。

[source, text]
.*1 - 定义变量数组*
----
users:
  bjones:
    first_name: Bob
    last_name: Jones
    home_dir: /users/bjones
  acook:
    first_name: Anne
    last_name: Cook
    home_dir: /users/acook
----

[source, text]
.*2 - 使用变量数组*
----
# Returns 'Bob'
users.bjones.first_name

# Returns '/users/acook'
users.acook.home_dir
----

*注册的变量* - 管理员可以使用 register 语句捕获命令的输出。输出保存在一个变量中，稍后可用于调试用途或者达成其他目的，例如基于命令输出的特定配置。

[source, text]
.*变量注册示例*
----
---
- name: Installs a package and prints the result
  hosts: all
  tasks:
    - name: Install the package
      yum:
        name: httpd
        state: installed
      register: install_result

    - debug: var=install_result
----

=== 事实(Facts)


=== 包含(Inclusions)

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

== Ansible Tower

Ansible Tower 提供了在企业规模上高效运行和管理 Ansible 的框架，包括管理 playbook 的集中式 Web 界面、基于角色的访问控制 (RBAC)以及集中式日志记录和审计、其 REST API 确保 Tower 与企业的现有工作流和工具集轻松集成。Tower 的 API 和通知功能让 Ansible playbook 与 Jenkins、CloudForms 或红帽卫星等其他工具的关联变得特别简单，从而实现持续集成和部署。它提供了相应的机制，可以实现集中使用和控制计算机凭据及其他机密，而不必将它们公开给 Ansible Tower 最终用户。

=== 架构

Ansible Tower 是一款 Django Web 应用，可在 Linux 服务器上作为企业内自托管解决方案运行，架设于企业的现有 Ansible 基础架构基础上：

image:img/ansible-tower.png[]

* *具有集成式数据库的单一计算机* - 所有 Tower 组件、Web 前端、RESTful API 后端和 PostgreSQL 数据库全部驻留于单一计算机上。这是标准的架构。
* *具有远程数据库的单一计算机* - Tower Web 前端和 RESTful API 后端安装在单一计算机上，而 PostgreSQL 数据库远程安装在同一网络中的另一台服务器上。远程数据库可以托管在具有 Tower 管理范围外现有 PostgreSQL 实例的服务器上。另一种方案是使 Tower 安装程序在远程服务器上创建 Tower 管理的 PostgreSQL 实例，并为它填充 Tower 数据库。
* *高可用性多计算机群集* - 较旧版本的 Tower 提供一种主动-被动式冗余 Tower 架构，其包含一个主动节点和一个或多个被动节点。自 Tower 3.1 起，这种架构现已被具有多个主动 tower 节点的主动-主动式高可用性群集取代。

=== 功能

|===
|条目 |说明

|可视化控制面板
|Tower Web 界面打开后显示一个控制面板屏幕，其中提供企业的整个 Ansible 环境的概要视图。通过 Tower 控制面板，管理员可以轻松查看主机和清单的当前状态，以及近期作业执行的结果。

|基于角色的访问控制 (RBAC)
|Tower 利用基于角色的访问控制 (RBAC) 系统，在维护安全性的同时简化用户访问权限管理。它简化了将用户访问权限委派至 Tower 对象（如组织、项目和清单）的过程。

|图形化清单管理
|用户在 Tower 中可以通过其 Web 界面创建清单组和添加清单主机。清单也可以从外部清单来源更新，如公共云提供商、本地虚拟化环境以及组织的自定义 配置管理数据库 (CMDB)。

|作业调度
|Tower 为用户提供调度 playbook 执行的功能，并在一次性或以固定间隔重复的基础上从外部数据源更新。这使得日常任务能够以无人值守的方式执行，对于最好在非工作时段执行的备份例程等任务特别有用。

|实时和历史作业状态报告
|如果 playbook 执行是从 Tower 中发起的，Web 界面中可实时显示 playbook 输出和执行结果。Tower 也提供以前执行的作业和调度的作业运行的结果。

|一键式自动化
|Ansible 简化了 IT 自动化，而 Tower 则进一步实现了用户自助服务。Tower 的简化 Web 界面与其 RBAC 系统的灵活性相结合，让管理员能够安全地以一键式例程方式委派复杂的任务。

|远程命令执行
|Tower 通过其远程命令执行功能提供 Ansible 临时命令的按需灵活性。远程命令执行用户权限通过 Tower 的 RBAC 系统实施。

|凭据管理
|Tower 集中管理用于身份验证目的的凭据，以执行包括如下在内的事务：在受管主机上运行 Ansible play，从动态清单源同步信息，以及从版本控制系统导入 Ansible 项目内容。它会加密提供的密码或密钥，使其不能被 Tower 用户检索到。可以授权用户来使用或替换这些凭据，而不必将它们公开给用户。

|集中式日志记录和审计
|Tower 上发起的所有 playbook 和远程命令执行都会记录日志。这提供了审计每个作业的执行时间以及执行人的功能。此外，Tower 也提供相应的功能，可以将其日志数据集成到第三方日志聚合解决方案中，如 Splunk 和 Sumologic。

|集成式通知
|Tower 通知可以用于指示 Tower 作业执行何时成功或失败。通知可以通过许多不同的协议传送，如电子邮件、Slack 和 HipChat 等。

|多 Playbook 工作流
|复杂的操作通常涉及连续执行多个 playbook。借助 Tower 的多 playbook 工作流，用户可以将多个 playbook 串联在一起，协助执行涉及调配、配置、部署和编排的复杂例程。直观的工作流编辑器也有助于简化多 playbook 工作流的建模。

|系统跟踪
|Tower 可以配置为定期扫描受管主机并记录其状态。收集的数据可用于审计随时间发生的系统变化。此外，这项功能也可用于比较和探查系统之间的差别。

|RESTful API
|Tower 的 RESTful API 通过 Tower Web 界面公开每一项 Tower 功能。API 的可浏览格式实现自我记录，并且简化 API 用法信息的查询。
|===

https://docs.ansible.com/ansible-tower/3.1.1/html/administration[Ansible Tower 管理文档]

=== 安装

.*Ansible Tower 安装需求*
[cols="2,5a"]
|===
|条目 |说明

|操作系统
|支持操作系统包括：

* Redhat Enterprise Linux 7
* CentOS 7
* Ubuntu 14.04 LTS
* Ubuntu 16.04 LTS 

例如，Ansible Tower 3.1 可安装在 RHEL 7.2 或更高的版本之上，并使用 64 位 x86_64 处理器架构

|Web 浏览器
|支持的 Mozilla Firefox 或 Google Chrome 版本，以连接 Ansible Tower Web 界面。其他 HTML5 兼容 Web 浏览器或许可行，但没有受到完整测试或支持。

|内存
|Tower 主机上要求至少 2 GB RAM。建议 4 GB 或以上。

|磁盘存储
|Tower 要求至少 20 GB 硬盘空间。若要 Ansible Tower 安装成功完成，/var 目录下必须有 10 GB 的可用磁盘空间。

|Ansible
|Ansible Tower 的安装通过执行运行 Ansible playbook 的 shell 脚本来进行。旧版 Ansible Tower 需要先安装最新稳定版 Ansible 后才能安装，但最新的安装程序会在 Ansible 及其依赖项不存在的情况下自动尝试安装它们。

|SELinux
|Tower 支持 targeted SELinux 策略，它可以设置为强制模式、许可或禁用。其他 SELinux 策略不受支持。

|受管客户端
|上述安装要求适用于 Ansible Tower 服务器，不适用于它通过 Ansible 管理的计算机。这些系统应满足通过 Ansible Tower 服务器上安装的 Ansible 版本管理的计算机的常规要求。
|===

*1. 下载* - http://releases.ansible.com/ansible-tower/setup/ansible-tower-setup-latest.el7.tar.gz，http://releases.ansible.com/ansible-tower/setup-bundle/ansible-tower-setup-bundle-latest.el7.tar.gz 提供另一种适用于 RHEL 7 的捆绑式安装程序。

[source, text]
.*2. 解压*
----
# tar xzf ansible-tower-setup-bundle-3.1.1-1.el7.tar.gz
# cd ansible-tower-setup-bundle-3.1.1-1.el7
----

[source, text]
.*3. 初始密码，辑 inventory 文件，以设置以下帐户的密码：Ansible Tower admin 帐户 (admin_password)、PostgreSQL 数据库用户帐户 (pg_password) 和 RabbitMQ 消息传递用户帐户 (rabbitmq_password)*
----
[tower]
localhost ansible_connection=local

[database]

[all:vars]
admin_password='myadminpassword'

pg_host=''
pg_port=''

pg_database='awx'
pg_username='awx'
pg_password='somedatabasepassword'

rabbitmq_port=5672
rabbitmq_vhost=tower
rabbitmq_username=tower
rabbitmq_password='and-a-messaging-password'
rabbitmq_cookie=cookiemonster

# Needs to be true for fqdns and ip addresses
rabbitmq_use_long_name=false
----

[source, text]
.*4. 执行 setup.sh 脚本来运行 Ansible Tower 安装程序*
----
# ./setup.sh
----

== 示例

|===
|编号 |说明 |链接

|1
|配置 httpd 并启用
|link:files/site.yml[site.yml]

|2
|多个 play 特权升级，一个 play 中配置 httpd，并确保防火墙运行 http 服务，另一个 play 中测试 http 服务
|link:files/intranet.yml[intranet.yml]

|3
|多个 play 特权升级，一个 play 中配置 httpd，并确保防火墙运行 http 服务, http 服务动态 php 应用连接 Mysql 数据库，另一个 play 中测试 http 服务
|link:files/internet.yml[internet.yml]

|===
