= Ansible
:toc: manual

== 什么是 Ansible

Ansible 是一款开源自动化平台，它是一款简单自动化语言，能够在 Ansible Playbook 中完美地描述 IT 基础架构。它同时提供了一个自动化引擎用来执行 Asible Playbook。

Ansible 具有多个重要的优点:

* *跨平台支持* - Ansible 提供 Linux、Windows、UNIX 和网络设备的无代理支持，适用于物理、虚拟、云和容器环境。
* *用户可读的自动化* - Ansible Playbook 采用 YAML 文本文件编写，易于阅读，有助于确保所有人都能理解它们的用途。
* *完美描述应用* - 可以通过 Ansible Playbook 进行每一种更改，并描述和记录应用环境的每一个方面。
* *轻松管理版本控制* - Ansible Playbook 和项目是纯文本。它们可以视作源代码，放在您的现有版本控制系统中。
* *支持动态清单* - 可以从外部来源动态更新 Ansible 管理的计算机的列表，随时获取所有受管服务器的当前正确列表，不受基础架构或位置的影响。
* *编排可与其他系统轻松集成* - 能够利用环境中现有的 HP SA、Puppet、Jenkins、红帽卫星和其他系统，并且集成到您的 Ansible 工作流中。

Ansible 是第一款可以在整个 IT 范围读取和编写的自动化语言。它也是唯一能够从头至尾自动化应用生命周期和持续交付管道的自动化引擎。

image:img/devops-language-diagram.png[]

Ansible 方式:

* *简单高效* - 越简单越好。Ansible 的设计宗旨是工具易用，自动化易写易读。您应利用这一特点在创建自动化时追求简单化。
* *专为易读性优化* - Ansible 自动化语言围绕简单易读的声明性文本文件来构建。正确编写的 Ansible Playbook 可以清楚地记录您的工作流自动化。
* *声明式思维* - Ansible 是一种要求状态引擎。它通过表达您希望系统处于何种状态来解决如何自动化 IT 部署的问题。Ansible 的目标是通过仅执行必要的更改，使您的系统处于所需的状态。试图将 Ansible 视为脚本语言并非正确的做法。

== 安装

Ansible 易于安装。Ansible 软件只需要安装到要运行它的一个（或多个）控制节点上。由 Ansible 管理的主机不需要安装 Ansible。这种安装涉及相对较少的步骤，其要求也最少。

控制节点应当是 Linux 或 UNIX 系统。不支持将 Microsoft Windows 用作控制节点，但 Windows 系统可以是受管主机。

[source, bash]
.*安装 1/3 - 安装 Python(本步骤是可选择的)*
----
sudo yum install -y python
----

[source, bash]
.*安装 2/3 - 安装 Ansible*
----
sudo yum install -y ansible
----

[source, bash]
.*安装 3/3 - 安装验证*
----
ansible --version
----

== 部署

=== Inventory 编写

Inventory 即清单，一个 清单定义 Ansible 将要管理的一系列主机。这些主机也可以分配到 组中，以便进行集中管理。组可以包含子组，主机也可以是多个组的成员。清单还可以设置应用到它所定义的主机和组的变量。

可以通过两种方式定义主机清单：

* 静态主机清单，可以通过文本文件来定义。
* 动态主机清单，可以根据需要利用外部信息提供程序通过脚本或其他程序来生成。

[source, text]
.*1. 静态清单示例*
----
[webservers]
web1.example.com
web2.example.com

[dbservers]
db1.example.com
db2.example.com

[allservers:children]
webservers
dbservers
----

[source, text]
.*2. 清单测试*
----
$ ansible allservers --list-hosts
  hosts (4):
    web1.example.com
    web2.example.com
    db1.example.com
    db2.example.com
----

清单文件可以覆盖 `/etc/ansible/hosts` 文件，也可以在允许时通过 `--inventory PATHNAME` 或 `-i PATHNAME` 选项在命令行中指定清单文件的位置，其中 PATHNAME 是所需清单文件的路径。

[source, text]
----
ansible -i Inventory
----

NOTE: 更多关于 Ansible 清单，参照 https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html[链接]。

=== 配置文件

.*Ansible 配置文件 & 优先级*
|===
|文件路径 |说明 |优先级

|$ANSIBLE_CONFIG
|使用 $ANSIBLE_CONFIG 变量指定配置文件路径，优先级最高
|4

|./ansible.cfg
|放置与执行 ansible 命令的目录
|3

|~/.ansible.cfg
|当前用户主目录下
|2

|/etc/ansible/ansible.cfg
|全局配置文件路径
|1
|===

NOTE: 优先级高的配置文件或覆盖优先级低的配置。

[source, text]
.*ansible --version 输出配置的位置*
----
$ ansible --version
ansible 2.3.1.0
  config file = /etc/ansible/ansible.cfg
...
----

[source, text]
.*执行 Ansible 命令时使用 -v 选项输出配置的位置*
----
$ ansible servers --list-hosts -v
Using /etc/ansible/ansible.cfg as config file
...
----

.*Ansible 配置文件中的配置分组*
[cols="2,2,5a"]
|===
|位置 |说明 |示例

|[defaults]
|配置文件中的大部分设置分组
|
[source, text]
----
[defaults]
#清单位置
inventory = ./inventory

#连接设置
remote_user = root
ask_pass = true
----

|[privilege_escalation]
|包含的设置用于定义如何对受管主机执行需要特权升级的操作。
|
[source, text]
----
[privilege_escalation]
become = true
become_method = sudo
become_user = root
become_ask_pass = false
----

|[paramiko_connection]、[ssh_connection]、[accelerate]
|包含的设置用于优化与受管主机的连接
|

|[selinux]
|包含的设置用于定义如何配置 SELinux 交互
|
|===

.*Ansible 配置项*
|===
|配置项 |说明 |命令行选项

|inventory
|Ansible 清单的位置
|-i

|remote_user
|用于建立与受管主机的连接的用户帐户
|-u

|ask_pass
|提示输入以远程用户身份连接时要使用的密码
|

|become
|为受管主机上的操作启用或禁用特权升级
|--become、-b

|become_method
|要在受管主机上使用的特权升级方法
|--become-method

|become_user
|在受管主机上升级特权的用户帐户
|--become-user

|become_ask_pass
|定义受管主机上的特权升级是否提示输入密码
|--ask-become-pass、 -K
|===

=== 运行临时命令

什么是运行临时命令？临时命令是简单的一行式操作，无需编写 playbook 即可运行的命令。它们对快速测试和更改很有用处。例如，您可以使用临时命令确保一组服务器上的 /etc/hosts 文件中存在某一特定的行。您可以使用另一个临时命令在许多不同的计算机上高效重启一项服务，或者确保特定的软件包为最新版本。您还可以将它用于在一个或多个主机上运行任意命令，从而运行某一程序或收集信息。

[source, text]
.*运行临时命令范式*
----
ansible host-pattern -m module [-a 'module arguments'] [-i inventory]
----

* `host-pattern` - 用于指定应在其上运行临时命令的受管主机。它可以是清单中的特定受管主机或主机组。
* `-m` -  Ansible 应在目标主机上运行的 模块的名称取为参数。模块是为了实施您的任务而执行的小程序。
* `-a` - 以带引号字符串形式取这些参数的列表。
* `-i` - 指定要使用的其他清单位置，取代当前 Ansible 配置文件中的默认位置。

[source, text]
.*ansible-doc -l 列出所有模块*
----
$ ansible-doc -l
----

[source, text]
.*ansible-doc NAME 查看模块文档*
----
$ ansible-doc ping
----

.*常见临时命令示例*
[cols="2,5a"]
|===
|名称 |示例

|ping
|
[source, text]
----
$ ansible all -m ping
servera.lab.example.com | SUCCESS => {
    "changed": false,
    "ping": "pong"
}
----

|创建用户
|
[source, text]
----
$ ansible -m user -a 'name=newbie uid=4000 state=present' \
> servera.lab.example.com
servera.lab.example.com | SUCCESS => {
    "changed": true,
    "comment": "",
    "createhome": true,
    "group": 4000,
    "home": "/home/newbie",
    "name": "newbie",
    "shell": "/bin/bash",
    "state": "present",
    "system": false,
    "uid": 4000
}
----

|使用 command 模块运行命令
|
[source, text]
----
$ ansible mymanagedhosts -m command -a /usr/bin/hostname -o
host1.lab.example.com | SUCCESS | rc=0 >> (stdout) host1.lab.example.com
host2.lab.example.com | SUCCESS | rc=0 >> (stdout) host2.lab.example.com
----

=== 动态清单

Ansible 支持通过 动态清单脚本在每当 Ansible 执行时从这些类型的来源检索当前的信息，使清单能够实时得到更新。这些脚本是可以执行的程序，能够从一些外部来源收集信息，并以 JSON 格式输出清单。

动态清单脚本的使用方式与静态清单文本文件一样。清单的位置可以直接在当前的 ansible.cfg 文件中指定，或者通过 -i 选项指定。如果清单文件可以执行，它将被视为动态清单程序，Ansible 则将尝试运行它来生成清单。如果文件不可执行，它将被视为静态清单。

NOTE: https://github.com/ansible/ansible/tree/devel/contrib/inventory 中有大量现有的动态清单脚本，包括对私有云平台、公共云平台、虚拟化平台、PaaS 平台等管理。
|===

== Playbooks

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

[source, text]
.*1*
----

----

